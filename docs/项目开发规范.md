# 项目开发规范

## 🎯 项目定位与原则

### 核心定位
**智能文档助手**专注于**文档组装、文风检测和智能审批**，不替代专业工具，而是帮助用户将分散的内容智能组装成高质量的专业文档。

**重要说明**：本系统为**单用户工具**，不支持多人协同编辑，专注于个人用户的文档处理需求。

### 开发原则
1. **用户价值优先** - 专注于解决用户实际痛点
2. **质量保证** - 确保文档质量和一致性
3. **效率提升** - 自动化繁琐的格式调整和检查工作
4. **专业标准** - 确保文档符合行业标准和规范
5. **单用户体验** - 优化个人用户的使用体验，不涉及协作功能

## 📋 代码规范

### Python代码规范

#### 1. 基本规范
- 遵循 **PEP 8** Python代码规范
- 使用 **Python 3.8+** 语法特性
- 所有函数必须有类型注解
- 所有类必须有文档字符串

#### 2. 命名规范
```python
# 类名：大驼峰命名法
class IntelligentImageProcessor:
    """智能图像处理器"""
    
# 函数名：小写字母+下划线
def process_document_content(content: str) -> Dict[str, Any]:
    """处理文档内容"""
    
# 变量名：小写字母+下划线
document_type = "patent"
processing_result = {}

# 常量名：大写字母+下划线
MAX_FILE_SIZE = 50 * 1024 * 1024  # 50MB
SUPPORTED_FORMATS = ['.docx', '.pdf', '.txt']
```

#### 3. 文档字符串规范
```python
def generate_svg_for_document(
    document_type: str, 
    content_description: str,
    svg_size: Tuple[int, int] = (400, 300)
) -> Dict[str, Any]:
    """
    根据文档类型和内容描述生成SVG图像
    
    Args:
        document_type: 文档类型 ('patent', 'project', 'general')
        content_description: 内容描述
        svg_size: SVG尺寸 (宽度, 高度)
        
    Returns:
        包含生成结果的字典:
        {
            'success': bool,
            'svg_path': str,
            'svg_content': str,
            'error': str (如果失败)
        }
        
    Raises:
        ValueError: 当文档类型无效时
        IOError: 当文件写入失败时
    """
```

#### 4. 错误处理规范
```python
def process_user_content(content: str) -> Dict[str, Any]:
    """处理用户内容"""
    try:
        # 主要处理逻辑
        result = perform_processing(content)
        return {
            'success': True,
            'result': result,
            'message': '处理成功'
        }
    except ValueError as e:
        # 处理参数错误
        return {
            'success': False,
            'error': f'参数错误: {str(e)}',
            'error_type': 'validation_error'
        }
    except Exception as e:
        # 处理其他错误
        logger.error(f"处理失败: {str(e)}")
        return {
            'success': False,
            'error': f'处理失败: {str(e)}',
            'error_type': 'processing_error'
        }
```

### JavaScript代码规范

#### 1. 基本规范
- 使用 **ES6+** 语法特性
- 使用 **const** 和 **let**，避免 **var**
- 使用 **async/await** 处理异步操作
- 所有函数必须有注释说明

#### 2. 命名规范
```javascript
// 函数名：小驼峰命名法
async function processDocumentContent(content) {
    // 处理逻辑
}

// 变量名：小驼峰命名法
const documentType = 'patent';
let processingResult = {};

// 常量名：大写字母+下划线
const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50MB
const SUPPORTED_FORMATS = ['.docx', '.pdf', '.txt'];
```

#### 3. 异步处理规范
```javascript
async function handleDocumentUpload(file) {
    try {
        showLoading('正在上传文档...');
        
        const formData = new FormData();
        formData.append('file', file);
        
        const response = await fetch('/api/upload', {
            method: 'POST',
            body: formData
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            showMessage('文档上传成功！', 'success');
            return result;
        } else {
            throw new Error(result.error || '上传失败');
        }
        
    } catch (error) {
        showMessage(`上传失败: ${error.message}`, 'error');
        return null;
    } finally {
        hideLoading();
    }
}
```

## 🏗️ 架构设计规范

### 1. 模块化设计
```
src/
├── core/                    # 核心业务模块
│   ├── agent/              # AI代理协调器
│   ├── analysis/           # 文档分析引擎
│   ├── tools/              # 核心工具集
│   ├── knowledge_base/     # 知识库
│   └── monitoring/         # 性能监控
├── llm_clients/            # LLM客户端
└── web_app.py             # Web应用入口
```

### 2. 接口设计规范
```python
# 所有工具类必须实现基础接口
class BaseTool:
    """工具基类"""
    
    def __init__(self):
        self.name = self.__class__.__name__
        self.version = "1.0.0"
    
    def process(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """处理输入数据"""
        raise NotImplementedError
    
    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """验证输入数据"""
        raise NotImplementedError
    
    def get_status(self) -> Dict[str, Any]:
        """获取工具状态"""
        return {
            'name': self.name,
            'version': self.version,
            'status': 'ready'
        }
```

### 3. 后端API接口开发规范

#### 3.1 接口开发流程
```
1. 需求分析 → 2. 接口设计 → 3. 后端实现 → 4. 接口文档更新 → 5. 前端调用示范 → 6. 测试验证
```

#### 3.2 新增后端接口必须遵循的规范

**强制要求**：
- ✅ **必须更新后端接口开发文档** (`docs/后端接口开发文档0626.md`)
- ✅ **必须设计前端调用示范说明**
- ✅ **必须包含完整的请求/响应格式**
- ✅ **必须提供错误处理示例**

#### 3.3 接口文档更新规范

**新增接口必须在文档中添加**：
```markdown
### 新功能模块接口

- **POST /api/new-feature/action**  
  功能：新功能描述。  
  描述：详细的功能说明和使用场景。
  
  **请求参数**：
  ```json
  {
    "param1": "string",
    "param2": "number",
    "param3": {
      "nested": "object"
    }
  }
  ```
  
  **响应格式**：
  ```json
  {
    "success": true,
    "result": {
      "data": "处理结果"
    },
    "message": "操作成功"
  }
  ```
  
  **错误响应**：
  ```json
  {
    "success": false,
    "error": "错误描述",
    "error_code": "ERROR_CODE"
  }
  ```
```

#### 3.4 前端调用示范规范

**必须提供完整的前端调用示例**：

```javascript
// 前端调用示范 - 新功能接口
async function callNewFeatureAPI(params) {
    try {
        // 显示加载状态
        showLoading('正在处理...');
        
        const response = await fetch('/api/new-feature/action', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(params)
        });
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const result = await response.json();
        
        if (result.success) {
            // 成功处理
            showMessage('操作成功！', 'success');
            return result.result;
        } else {
            // 业务错误
            throw new Error(result.error || '操作失败');
        }
        
    } catch (error) {
        // 错误处理
        showMessage(`操作失败: ${error.message}`, 'error');
        console.error('API调用失败:', error);
        return null;
    } finally {
        // 隐藏加载状态
        hideLoading();
    }
}

// 使用示例
const params = {
    param1: 'value1',
    param2: 123,
    param3: { nested: 'value' }
};

const result = await callNewFeatureAPI(params);
if (result) {
    // 处理成功结果
    console.log('处理结果:', result);
}
```

#### 3.5 接口实现规范

**后端接口实现必须包含**：
```python
@app.route('/api/new-feature/action', methods=['POST'])
def new_feature_action():
    """
    新功能接口
    
    请求参数:
    {
        "param1": "string - 参数1说明",
        "param2": "number - 参数2说明",
        "param3": {
            "nested": "string - 嵌套参数说明"
        }
    }
    
    响应格式:
    {
        "success": true,
        "result": {
            "data": "处理结果"
        },
        "message": "操作成功"
    }
    
    错误响应:
    {
        "success": false,
        "error": "错误描述",
        "error_code": "ERROR_CODE"
    }
    """
    try:
        # 1. 参数验证
        data = request.get_json()
        if not data:
            return jsonify({
                'success': False,
                'error': '请求参数不能为空',
                'error_code': 'INVALID_PARAMS'
            }), 400
        
        # 2. 参数提取和验证
        param1 = data.get('param1')
        param2 = data.get('param2')
        param3 = data.get('param3', {})
        
        if not param1:
            return jsonify({
                'success': False,
                'error': 'param1是必需参数',
                'error_code': 'MISSING_PARAM1'
            }), 400
        
        # 3. 业务逻辑处理
        result = process_new_feature(param1, param2, param3)
        
        # 4. 返回成功响应
        return jsonify({
            'success': True,
            'result': result,
            'message': '操作成功'
        })
        
    except ValueError as e:
        # 参数错误
        return jsonify({
            'success': False,
            'error': f'参数错误: {str(e)}',
            'error_code': 'VALIDATION_ERROR'
        }), 400
        
    except Exception as e:
        # 系统错误
        logger.error(f"新功能处理失败: {str(e)}")
        return jsonify({
            'success': False,
            'error': f'系统错误: {str(e)}',
            'error_code': 'SYSTEM_ERROR'
        }), 500
```

#### 3.6 接口测试规范

**必须包含的测试用例**：
```python
class TestNewFeatureAPI(unittest.TestCase):
    """新功能接口测试"""
    
    def test_new_feature_success(self):
        """测试成功场景"""
        data = {
            "param1": "test_value",
            "param2": 123,
            "param3": {"nested": "test"}
        }
        
        response = self.client.post('/api/new-feature/action', 
                                  json=data)
        
        self.assertEqual(response.status_code, 200)
        result = response.get_json()
        self.assertTrue(result['success'])
        self.assertIn('result', result)
    
    def test_new_feature_missing_params(self):
        """测试缺少参数场景"""
        data = {"param2": 123}  # 缺少param1
        
        response = self.client.post('/api/new-feature/action', 
                                  json=data)
        
        self.assertEqual(response.status_code, 400)
        result = response.get_json()
        self.assertFalse(result['success'])
        self.assertIn('param1是必需参数', result['error'])
    
    def test_new_feature_invalid_params(self):
        """测试无效参数场景"""
        data = {
            "param1": "",  # 空字符串
            "param2": "not_a_number"  # 非数字
        }
        
        response = self.client.post('/api/new-feature/action', 
                                  json=data)
        
        self.assertEqual(response.status_code, 400)
        result = response.get_json()
        self.assertFalse(result['success'])
```

#### 3.7 文档同步检查清单

**开发完成后必须检查**：
- [ ] 后端接口开发文档已更新 (`docs/后端接口开发文档0626.md`)
- [ ] 前端调用示范已编写并测试
- [ ] 接口参数和响应格式已完整记录
- [ ] 错误处理场景已覆盖
- [ ] 测试用例已编写并通过
- [ ] 代码注释已完善
- [ ] Git提交信息符合规范

### 4. 配置管理规范
```python
# 使用YAML配置文件
# config/config.yaml
app:
  name: "智能文档助手"
  version: "3.0.0"
  debug: false

llm:
  default_provider: "xingcheng"
  providers:
    xingcheng:
      api_key: "${XINGCHENG_API_KEY}"
      api_secret: "${XINGCHENG_API_SECRET}"
    qiniu:
      api_key: "${QINIU_API_KEY}"

processing:
  max_file_size: 52428800  # 50MB
  supported_formats: [".docx", ".pdf", ".txt"]
  temp_dir: "./temp"
```

## 🧪 测试规范

### 1. 测试文件命名
```
tests/
├── test_svg_integration.py           # SVG集成测试
├── test_comprehensive_integration.py # 综合集成测试
├── test_e2e_framework.py             # 端到端测试框架
├── test_writing_style_analysis.py    # 文风分析测试
└── test_document_fill.py             # 文档填充测试
```

### 2. 测试用例规范
```python
class TestSVGIntegration(unittest.TestCase):
    """SVG集成功能测试类"""
    
    def setUp(self):
        """测试前准备"""
        self.image_processor = IntelligentImageProcessor()
        self.temp_dir = tempfile.mkdtemp()
    
    def test_generate_svg_image(self):
        """测试SVG图像生成"""
        print("测试SVG图像生成...")
        
        # 测试逻辑
        result = self.image_processor.generate_svg_image(...)
        
        # 断言验证
        self.assertTrue(result["success"])
        self.assertIn("svg_path", result)
        
        print("✓ SVG生成成功")
    
    def tearDown(self):
        """测试后清理"""
        if hasattr(self, 'temp_dir') and os.path.exists(self.temp_dir):
            shutil.rmtree(self.temp_dir)
```

### 3. 测试覆盖率要求
- **单元测试**: 85%+
- **集成测试**: 90%+
- **端到端测试**: 80%+
- **性能测试**: 75%+

## 📝 文档规范

### 1. 代码注释规范
```python
# 单行注释：解释复杂逻辑
complex_calculation = (base_value * multiplier) + offset

# 多行注释：解释复杂算法
"""
算法说明：
1. 首先进行数据预处理
2. 然后应用核心算法
3. 最后进行结果验证
"""

def complex_algorithm(data):
    # 步骤1：数据预处理
    processed_data = preprocess(data)
    
    # 步骤2：核心算法
    result = core_algorithm(processed_data)
    
    # 步骤3：结果验证
    validated_result = validate_result(result)
    
    return validated_result
```

### 2. API文档规范
```python
@app.route('/api/svg/generate', methods=['POST'])
def generate_svg_image():
    """
    生成SVG图像API
    
    请求参数:
    {
        "document_type": "patent|project|general",
        "content_description": "内容描述",
        "svg_size": [400, 300]
    }
    
    响应格式:
    {
        "success": true,
        "svg_path": "/path/to/svg",
        "svg_content": "<svg>...</svg>",
        "svg_id": "unique_id"
    }
    
    错误响应:
    {
        "success": false,
        "error": "错误信息"
    }
    """
```

### 3. 前后端接口文档一致性规范

#### 3.1 接口文档同步要求
- ✅ **后端接口开发文档** (`docs/后端接口开发文档0626.md`) 必须与代码实现保持同步
- ✅ **前端调用示范** 必须与后端接口定义完全一致
- ✅ **请求/响应格式** 必须前后端统一
- ✅ **错误处理机制** 必须前后端协调

#### 3.2 接口文档更新流程
```
后端接口变更 → 更新后端接口文档 → 更新前端调用示范 → 同步测试用例 → 验证一致性
```

#### 3.3 接口文档检查清单
**每次接口变更后必须检查**：
- [ ] 后端接口开发文档已更新
- [ ] 前端调用示范已同步更新
- [ ] 请求参数格式前后端一致
- [ ] 响应数据格式前后端一致
- [ ] 错误码和错误信息前后端一致
- [ ] 测试用例已更新并通过
- [ ] 文档版本号已更新

#### 3.4 接口文档模板规范

**后端接口文档模板**：
```markdown
### 功能模块名称

- **POST /api/module/action**  
  功能：功能描述。  
  描述：详细的功能说明和使用场景。
  
  **请求参数**：
  ```json
  {
    "param1": "string - 参数1说明",
    "param2": "number - 参数2说明",
    "param3": {
      "nested": "string - 嵌套参数说明"
    }
  }
  ```
  
  **响应格式**：
  ```json
  {
    "success": true,
    "result": {
      "data": "处理结果"
    },
    "message": "操作成功"
  }
  ```
  
  **错误响应**：
  ```json
  {
    "success": false,
    "error": "错误描述",
    "error_code": "ERROR_CODE"
  }
  ```
  
  **前端调用示例**：
  ```javascript
  async function callModuleAPI(params) {
      try {
          const response = await fetch('/api/module/action', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(params)
          });
          
          const result = await response.json();
          if (result.success) {
              return result.result;
          } else {
              throw new Error(result.error);
          }
      } catch (error) {
          console.error('API调用失败:', error);
          throw error;
      }
  }
  ```
```

#### 3.5 版本控制规范
- 接口文档版本号格式：`v主版本.次版本.修订版本`
- 重大接口变更必须升级主版本号
- 新增接口功能升级次版本号
- 文档修正升级修订版本号
- 每次更新必须在文档头部记录变更历史

#### 3.6 接口文档维护责任
- **后端开发者**：负责后端接口文档的准确性和完整性
- **前端开发者**：负责前端调用示范的正确性和可用性
- **项目负责人**：负责接口文档的整体协调和版本管理
- **测试人员**：负责验证前后端接口文档的一致性

## 🔄 工作流程规范

### 1. 开发流程
```
1. 文档先行 → 2. 状态检测 → 3. 设计方案 → 4. 代码实现 → 5. 测试验证 → 6. Git提交
```

### 2. Git提交规范
```bash
# 提交格式
<type>(<scope>): <subject>

# 类型说明
feat:     新功能
fix:      修复bug
docs:     文档更新
style:    代码格式调整
refactor: 代码重构
test:     测试相关
chore:    构建过程或辅助工具的变动

# 示例
feat(svg): 添加SVG生成和插入功能
fix(api): 修复文档上传API错误
docs(readme): 更新项目定位和功能介绍
```

### 3. 分支管理规范
```
main          # 主分支，稳定版本
develop       # 开发分支，集成测试
feature/*     # 功能分支
hotfix/*      # 紧急修复分支
release/*     # 发布分支
```

## 🎯 质量保证规范

### 1. 代码审查要求
- 所有代码必须经过审查
- 审查重点：功能正确性、代码质量、安全性
- 审查人员：至少1名资深开发者

### 2. 性能要求
- 响应时间：平均2-5秒
- 并发处理：支持10+并发用户
- 内存使用：控制在4GB以内
- CPU使用率：平均30-50%

### 3. 安全要求
- 输入验证：所有用户输入必须验证
- 文件上传：限制文件类型和大小
- API安全：使用HTTPS，验证API密钥
- 数据保护：敏感数据加密存储

## 🚀 部署规范

### 1. 环境配置
```bash
# 生产环境配置
export FLASK_ENV=production
export FLASK_DEBUG=false
export DATABASE_URL=sqlite:///production.db
export LOG_LEVEL=INFO
```

### 2. 启动脚本
```bash
#!/bin/bash
# start.sh

# 检查环境
python -c "import sys; sys.exit(0 if sys.version_info >= (3,8) else 1)"

# 安装依赖
pip install -r requirements.txt

# 启动应用
python -m src.web_app
```

### 3. 监控要求
- 应用健康检查
- 性能监控
- 错误日志记录
- 资源使用监控

## 📋 检查清单

### 开发前检查
- [ ] 已阅读项目定位和开发原则
- [ ] 了解相关功能模块
- [ ] 明确开发目标和范围
- [ ] 准备好测试方案

### 开发中检查
- [ ] 遵循代码规范
- [ ] 添加必要的注释
- [ ] 编写测试用例
- [ ] 进行代码审查

### 开发后检查
- [ ] 所有测试通过
- [ ] 文档已更新
- [ ] 代码已提交
- [ ] 功能已验证
- [ ] **后端接口开发文档已同步更新**
- [ ] **前端调用示范已编写并测试**
- [ ] **接口参数和响应格式前后端一致**
- [ ] **错误处理机制前后端协调**

---

**最后更新**: 2025-01-27  
**版本**: v3.1  
**适用范围**: 所有项目开发工作
